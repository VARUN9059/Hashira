import java.math.BigInteger;
import java.util.*;
import java.util.regex.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        StringBuilder sb = new StringBuilder();
        while (sc.hasNextLine()) {
            sb.append(sc.nextLine());
        }
        sc.close();

        String json = sb.toString();

        // Extract n and k
        int n = Integer.parseInt(matchFirst(json, "\"n\"\\s*:\\s*(\\d+)"));
        int k = Integer.parseInt(matchFirst(json, "\"k\"\\s*:\\s*(\\d+)"));

        List<BigInteger> roots = new ArrayList<>();

        // Loop through possible keys 1..n
        for (int i = 1; i <= n; i++) {
            String keyPattern = "\"" + i + "\"\\s*:\\s*\\{([^}]*)\\}";
            String block = matchFirst(json, keyPattern);
            if (block == null) continue;

            String baseStr = matchFirst(block, "\"base\"\\s*:\\s*\"(\\d+)\"");
            String valueStr = matchFirst(block, "\"value\"\\s*:\\s*\"([^\"]+)\"");

            if (baseStr == null || valueStr == null) continue;

            int base = Integer.parseInt(baseStr);

            // Validate the value for the given base
            if (!isValidForBase(valueStr.toLowerCase(), base)) {
                System.out.println("Skipping invalid value for base " + base + ": " + valueStr);
                continue;
            }

            try {
                BigInteger num = new BigInteger(valueStr, base);
                roots.add(num);
            } catch (Exception e) {
                System.out.println("Error parsing value: " + valueStr + " in base " + base);
            }
        }

        if (roots.size() < k) {
            System.out.println("Not enough valid roots.");
            return;
        }

        BigInteger product = BigInteger.ONE;
        for (int i = 0; i < k; i++) {
            product = product.multiply(roots.get(i));
        }

        if (k % 2 != 0) product = product.negate();

        System.out.println(product);
    }

    // Helper method to extract first regex group match
    private static String matchFirst(String text, String regex) {
        Pattern p = Pattern.compile(regex);
        Matcher m = p.matcher(text);
        if (m.find()) {
            return m.group(1);
        }
        return null;
    }

    // Validate if a number string is valid for a given base
    private static boolean isValidForBase(String value, int base) {
        String validChars;
        if (base <= 10) {
            validChars = "0-" + (base - 1);
        } else {
            validChars = "0-9a-" + (char) ('a' + base - 11);
        }
        return value.matches("[" + validChars + "]+");
    }
}



TestCase 1:
{
    "keys": {
        "n": 4,
        "k": 3
    },
    "1": { "base": "10", "value": "4" },
    "2": { "base": "2", "value": "111" },
    "3": { "base": "10", "value": "12" },
    "6": { "base": "4", "value": "213" }
}

output:-336


TestCase 2:

{
  "keys": {
    "n": 10,
    "k": 7
  },
  "1": { "base": "6", "value": "13444211440455345511" },
  "2": { "base": "15", "value": "aed7015a346b635" },
  "3": { "base": "15", "value": "6aee969631c227c" },
  "4": { "base": "16", "value": "e1b5e05623d881f" },
  "5": { "base": "8", "value": "316034514573652620673" },
  "6": { "base": "3", "value": "2122212201122002221120200210011020220200" },
  "7": { "base": "3", "value": "20120221122211000100210021102001201112121" },
  "8": { "base": "6", "value": "20220554335330240002224253" },
  "9": { "base": "12", "value": "45153788322a1255483" },
  "10": { "base": "7", "value": "1101613130313526312514143" }
}

output:

-68250911470551363173620811555205672583288683342284421727066668588894103671417909846443903240103706935841232112881346564357150
